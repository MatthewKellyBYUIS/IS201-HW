<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Cyber Turtle</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <style>
    /* Google Font */
    @import url("https://fonts.googleapis.com/css2?family=Orbitron:wght@400;600;800&display=swap");

    :root {
      --bg-main: #050816;
      --bg-panel: #0b1020;
      --accent-primary: #00f6ff;
      --accent-secondary: #ff00d4;
      --accent-tertiary: #33ff88;
      --text-main: #e5f4ff;
      --text-subtle: #7f8ba7;
      --danger: #ff3366;
      --shadow-strong: 0 0 35px rgba(0, 246, 255, 0.5);
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
      background: radial-gradient(circle at top, #141835 0, #050816 55%);
      color: var(--text-main);
      font-family: "Orbitron", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
    }

    .shell {
      width: min(960px, 100vw - 2rem);
      background: linear-gradient(145deg, #050816 0, #090f21 50%, #050816 100%);
      border-radius: 24px;
      padding: 1.5rem 1.75rem 1.75rem;
      box-shadow:
        0 0 0 1px rgba(0, 246, 255, 0.2),
        0 22px 60px rgba(0, 0, 0, 0.9);
      border: 1px solid rgba(255, 255, 255, 0.04);
      position: relative;
      overflow: hidden;
    }

    .shell::before,
    .shell::after {
      content: "";
      position: absolute;
      width: 110px;
      height: 110px;
      border-radius: 50%;
      filter: blur(22px);
      z-index: 0;
      opacity: 0.6;
    }

    .shell::before {
      top: -40px;
      right: -20px;
      background: radial-gradient(circle, var(--accent-primary), transparent);
    }

    .shell::after {
      bottom: -40px;
      left: -20px;
      background: radial-gradient(circle, var(--accent-secondary), transparent);
    }

    .shell-inner {
      position: relative;
      z-index: 1;
    }

    header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      gap: 1rem;
      margin-bottom: 1.25rem;
    }

    .title-block {
      display: flex;
      flex-direction: column;
      gap: 0.35rem;
    }

    h1 {
      font-size: clamp(1.6rem, 2.2vw, 2.1rem);
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--accent-primary);
      text-shadow: 0 0 12px rgba(0, 246, 255, 0.7);
    }

    .subtitle {
      font-size: 0.85rem;
      color: var(--text-subtle);
      text-transform: uppercase;
      letter-spacing: 0.18em;
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 0.3rem;
      font-size: 0.75rem;
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      background: rgba(0, 246, 255, 0.06);
      border: 1px solid rgba(0, 246, 255, 0.5);
      color: var(--accent-primary);
    }

    .badge-dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: var(--accent-tertiary);
      box-shadow: 0 0 10px var(--accent-tertiary);
    }

    .right-meta {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      gap: 0.25rem;
      font-size: 0.75rem;
      color: var(--text-subtle);
    }

    .meta-chip {
      padding: 0.3rem 0.6rem;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      background: rgba(3, 7, 18, 0.7);
    }

    .grid {
      display: grid;
      grid-template-columns: minmax(0, 2.2fr) minmax(0, 1.2fr);
      gap: 1.5rem;
      align-items: start;
    }

    @media (max-width: 800px) {
      .grid {
        grid-template-columns: minmax(0, 1fr);
      }
    }

    /* Game Panel */

    .game-panel {
      background: radial-gradient(circle at top, #111729 0, #050816 55%);
      border-radius: 18px;
      padding: 1rem;
      border: 1px solid rgba(0, 246, 255, 0.18);
      box-shadow: var(--shadow-strong);
      position: relative;
    }

    .game-panel::before {
      content: "";
      position: absolute;
      inset: 0;
      border-radius: inherit;
      border: 1px dashed rgba(0, 246, 255, 0.28);
      opacity: 0.4;
      pointer-events: none;
    }

    .screen-top {
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
      margin-bottom: 0.75rem;
    }

    .score-blocks {
      display: flex;
      gap: 0.5rem;
      font-size: 0.9rem;
    }

    .score-card {
      padding: 0.35rem 0.7rem;
      border-radius: 10px;
      background: rgba(0, 0, 0, 0.5);
      border: 1px solid rgba(0, 246, 255, 0.35);
      display: flex;
      flex-direction: column;
      gap: 0.1rem;
      min-width: 88px;
    }

    .score-label {
      font-size: 0.6rem;
      letter-spacing: 0.16em;
      text-transform: uppercase;
      color: var(--text-subtle);
    }

    .score-value {
      font-size: 1rem;
      font-weight: 600;
      color: var(--accent-tertiary);
    }

    .score-card--high .score-value {
      color: var(--accent-secondary);
    }

    .status {
      font-size: 0.75rem;
      text-align: right;
      color: var(--accent-primary);
      text-shadow: 0 0 8px rgba(0, 246, 255, 0.7);
    }

    .canvas-wrap {
      position: relative;
      border-radius: 14px;
      overflow: hidden;
      box-shadow:
        0 0 0 1px rgba(0, 246, 255, 0.25),
        0 16px 40px rgba(0, 0, 0, 0.85);
    }

    canvas {
      display: block;
      width: 100%;
      height: auto;
      background-color: #020712;
    }

    .canvas-overlay-border {
      position: absolute;
      inset: 0;
      border-radius: inherit;
      border: 3px solid transparent;
      border-image: linear-gradient(
        120deg,
        var(--accent-primary),
        var(--accent-secondary),
        var(--accent-tertiary)
      ) 1;
      mix-blend-mode: screen;
      pointer-events: none;
    }

    .hint-bar {
      margin-top: 0.75rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 0.75rem;
      font-size: 0.75rem;
      color: var(--text-subtle);
    }

    .keys {
      display: flex;
      gap: 0.3rem;
      flex-wrap: wrap;
      align-items: center;
    }

    .key {
      min-width: 20px;
      height: 20px;
      border-radius: 6px;
      border: 1px solid rgba(148, 163, 184, 0.6);
      display: inline-flex;
      align-items: center;
      justify-content: center;
      font-size: 0.6rem;
      text-transform: uppercase;
      background: radial-gradient(circle at top, #111827 0, #020617 60%);
      box-shadow: 0 2px 0 rgba(15, 23, 42, 0.9);
    }

    button {
      border: none;
      border-radius: 999px;
      padding: 0.4rem 0.9rem;
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      background-image: linear-gradient(
        120deg,
        var(--accent-secondary),
        var(--accent-primary)
      );
      color: #020617;
      cursor: pointer;
      font-weight: 700;
      box-shadow:
        0 0 14px rgba(255, 0, 212, 0.4),
        0 0 10px rgba(0, 246, 255, 0.3);
      transition: transform 0.1s ease, box-shadow 0.1s ease, filter 0.1s ease;
    }

    button:hover {
      transform: translateY(-1px) scale(1.02);
      filter: brightness(1.08);
    }

    button:active {
      transform: translateY(1px) scale(0.98);
      box-shadow:
        0 0 8px rgba(255, 0, 212, 0.2),
        0 0 6px rgba(0, 246, 255, 0.2);
    }

    /* Right Column */

    .side-panel {
      background: radial-gradient(circle at top left, #111827 0, #050816 55%);
      border-radius: 18px;
      padding: 0.9rem 1rem 1rem;
      border: 1px solid rgba(148, 163, 184, 0.25);
      backdrop-filter: blur(10px);
      color: var(--text-subtle);
      font-size: 0.8rem;
    }

    .side-title {
      font-size: 0.9rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      margin-bottom: 0.5rem;
      color: var(--accent-primary);
    }

    .side-panel p {
      margin-bottom: 0.65rem;
      line-height: 1.5;
    }

    .side-section {
      margin-top: 0.75rem;
    }

    .side-section h3 {
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.16em;
      color: var(--accent-secondary);
      margin-bottom: 0.3rem;
    }

    .controls-list {
      list-style: none;
      display: grid;
      gap: 0.25rem;
    }

    .controls-list li {
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }

    .dot {
      width: 6px;
      height: 6px;
      border-radius: 999px;
      background: var(--accent-tertiary);
    }

    .danger-text {
      color: var(--danger);
    }
  </style>
</head>
<body>
  <div class="shell">
    <div class="shell-inner">
      <header>
        <div class="title-block">
          <h1>Turtle.exe</h1>
          <span class="subtitle">Cyberpunk shell runner</span>
          <span class="badge">
            <span class="badge-dot"></span>
            LIVE BUILD // V1.1
          </span>
        </div>
        <div class="right-meta">
          <div class="meta-chip">ARROWS or WASD to move</div>
          <div class="meta-chip">SPACE to start / restart</div>
        </div>
      </header>

      <div class="grid">
        <!-- GAME PANEL -->
        <section class="game-panel" aria-label="Cyber turtle game">
          <div class="screen-top">
            <div class="score-blocks">
              <div class="score-card">
                <span class="score-label">Score</span>
                <span class="score-value" id="score">0</span>
              </div>
              <div class="score-card score-card--high">
                <span class="score-label">High Score</span>
                <span class="score-value" id="highScore">0</span>
              </div>
            </div>
            <div class="status" id="status">Press SPACE or click START</div>
          </div>

          <div class="canvas-wrap">
            <canvas id="game" width="400" height="400"></canvas>
            <div class="canvas-overlay-border"></div>
          </div>

          <div class="hint-bar">
            <div class="keys">
              <span class="key">↑</span>
              <span class="key">↓</span>
              <span class="key">←</span>
              <span class="key">→</span>
              <span style="margin-inline: 0.2rem;">or</span>
              <span class="key">W</span>
              <span class="key">A</span>
              <span class="key">S</span>
              <span class="key">D</span>
            </div>
            <button id="startBtn">Start</button>
          </div>
        </section>

        <!-- INFO PANEL -->
        <aside class="side-panel">
          <h2 class="side-title">System Briefing</h2>
          <p>
            You’re piloting a neon cyber-turtle through a hostile grid. Collect
            shifting energy cores to grow your shell-train and push the high
            score beyond the system limit.
          </p>
          <p>
            Each bite increases your length and speed. Colliding with the wall
            or your own trail will instantly derez the turtle.
          </p>

          <div class="side-section">
            <h3>Core Controls</h3>
            <ul class="controls-list">
              <li><span class="dot"></span><span>Use <strong>Arrow Keys</strong> or <strong>WASD</strong> to move.</span></li>
              <li><span class="dot"></span><span>Press <strong>SPACE</strong> or <strong>START</strong> to begin / restart.</span></li>
              <li><span class="dot"></span><span>No 180° turns: you can’t instantly reverse direction.</span></li>
            </ul>
          </div>

          <div class="side-section">
            <h3>Survival Tips</h3>
            <ul class="controls-list">
              <li><span class="dot"></span><span>Think ahead – leave pathways for your future shell.</span></li>
              <li><span class="dot"></span><span>Loop around the grid to keep your tail manageable.</span></li>
              <li><span class="dot"></span><span class="danger-text">Wall corners + long shell = instant derez.</span></li>
            </ul>
          </div>
        </aside>
      </div>
    </div>
  </div>

  <script>
    (function () {
      const canvas = document.getElementById("game");
      const ctx = canvas.getContext("2d");

      const GRID_SIZE = 20; // pixels per cell
      const GRID_COUNT = canvas.width / GRID_SIZE;

      const scoreEl = document.getElementById("score");
      const highScoreEl = document.getElementById("highScore");
      const statusEl = document.getElementById("status");
      const startBtn = document.getElementById("startBtn");

      const FOOD_MOVE_INTERVAL = 5 * 60 * 1000; // 5 minutes in ms

      // Different visual "images" for the food core
      const FOOD_STYLES = [
        { inner: "#ffffff", mid: "#00f6ff", outer: "rgba(0,246,255,0)", icon: "◎" },
        { inner: "#ffffff", mid: "#ff00d4", outer: "rgba(255,0,212,0)", icon: "✶" },
        { inner: "#ffffff", mid: "#33ff88", outer: "rgba(51,255,136,0)", icon: "◆" },
        { inner: "#ffffff", mid: "#facc15", outer: "rgba(250,204,21,0)", icon: "★" }
      ];

      let snake = []; // still called snake internally, but visually it's a turtle train
      let direction = { x: 1, y: 0 };
      let nextDirection = { x: 1, y: 0 };
      let food = { x: 10, y: 10 };
      let score = 0;
      let highScore = 0;
      let intervalId = null;
      let foodMoveTimerId = null;
      let speed = 120; // ms per tick
      let currentFoodStyleIndex = 0;

      // Load high score from localStorage if available
      (function initHighScore() {
        try {
          const stored = localStorage.getItem("cyberTurtleHighScore");
          if (stored !== null) {
            highScore = parseInt(stored, 10) || 0;
            highScoreEl.textContent = highScore;
          }
        } catch (e) {
          // localStorage might be blocked; ignore
        }
      })();

      function resetGame() {
        snake = [
          { x: 8, y: 10 },
          { x: 7, y: 10 },
          { x: 6, y: 10 },
        ];
        direction = { x: 1, y: 0 };
        nextDirection = { x: 1, y: 0 };
        score = 0;
        speed = 120;
        scoreEl.textContent = score;
        placeFood();
        statusEl.textContent = "RUNNING...";

        clearInterval(intervalId);
        clearInterval(foodMoveTimerId);

        intervalId = setInterval(tick, speed);

        // Food auto-move timer (and style change)
        foodMoveTimerId = setInterval(() => {
          placeFood();
          draw();
        }, FOOD_MOVE_INTERVAL);

        draw();
      }

      function tick() {
        // Apply buffered direction
        direction = nextDirection;

        const head = {
          x: snake[0].x + direction.x,
          y: snake[0].y + direction.y,
        };

        // Check wall collision
        if (
          head.x < 0 ||
          head.x >= GRID_COUNT ||
          head.y < 0 ||
          head.y >= GRID_COUNT
        ) {
          return gameOver();
        }

        // Check self collision
        if (snake.some((seg) => seg.x === head.x && seg.y === head.y)) {
          return gameOver();
        }

        snake.unshift(head);

        // Food eaten
        if (head.x === food.x && head.y === food.y) {
          score++;
          scoreEl.textContent = score;

          if (score > highScore) {
            highScore = score;
            highScoreEl.textContent = highScore;
            try {
              localStorage.setItem("cyberTurtleHighScore", String(highScore));
            } catch (e) {}
          }

          placeFood();
          maybeSpeedUp();
        } else {
          snake.pop();
        }

        draw();
      }

      function gameOver() {
        clearInterval(intervalId);
        clearInterval(foodMoveTimerId);
        intervalId = null;
        foodMoveTimerId = null;
        statusEl.textContent = "GAME OVER — Press SPACE or START to hatch again";
        draw(true);
      }

      function maybeSpeedUp() {
        // Slight speed increase every 4 points (min 60ms)
        if (score > 0 && score % 4 === 0 && speed > 60) {
          speed -= 6;
          clearInterval(intervalId);
          intervalId = setInterval(tick, speed);
        }
      }

      function placeFood() {
        let newFood;
        while (true) {
          newFood = {
            x: Math.floor(Math.random() * GRID_COUNT),
            y: Math.floor(Math.random() * GRID_COUNT),
          };
          const onSnake = snake.some(
            (seg) => seg.x === newFood.x && seg.y === newFood.y
          );
          if (!onSnake) break;
        }
        food = newFood;
        currentFoodStyleIndex =
          (currentFoodStyleIndex + 1) % FOOD_STYLES.length;
      }

      function draw(isGameOver = false) {
        // Clear background
        ctx.fillStyle = "#020712";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Grid lines
        ctx.lineWidth = 1;
        ctx.strokeStyle = "rgba(0, 255, 180, 0.08)";
        ctx.beginPath();
        for (let i = 0; i <= GRID_COUNT; i++) {
          // vertical
          ctx.moveTo(i * GRID_SIZE + 0.5, 0);
          ctx.lineTo(i * GRID_SIZE + 0.5, canvas.height);
          // horizontal
          ctx.moveTo(0, i * GRID_SIZE + 0.5);
          ctx.lineTo(canvas.width, i * GRID_SIZE + 0.5);
        }
        ctx.stroke();

        // Draw food (changing color / icon core)
        const fx = food.x * GRID_SIZE;
        const fy = food.y * GRID_SIZE;
        const centerX = fx + GRID_SIZE / 2;
        const centerY = fy + GRID_SIZE / 2;
        const radius = GRID_SIZE * 0.35;

        const style = FOOD_STYLES[currentFoodStyleIndex];
        const gradient = ctx.createRadialGradient(
          centerX,
          centerY,
          radius * 0.1,
          centerX,
          centerY,
          radius
        );
        gradient.addColorStop(0, style.inner);
        gradient.addColorStop(0.35, style.mid);
        gradient.addColorStop(0.95, style.outer);

        ctx.fillStyle = gradient;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
        ctx.fill();

        ctx.font = "bold 14px Orbitron, system-ui";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillStyle = "#020617";
        ctx.fillText(style.icon, centerX, centerY + 1);

        // Draw turtle segments
        snake.forEach((seg, index) => {
          const x = seg.x * GRID_SIZE;
          const y = seg.y * GRID_SIZE;

          const isHead = index === 0;
          const t = index / Math.max(1, snake.length - 1);

          // Shell gradient
          const shellGradient = ctx.createLinearGradient(
            x,
            y,
            x + GRID_SIZE,
            y + GRID_SIZE
          );
          if (isHead) {
            shellGradient.addColorStop(0, "#4ade80"); // bright green
            shellGradient.addColorStop(1, "#22c55e");
          } else {
            shellGradient.addColorStop(
              0,
              `rgba(34,197,94,${0.9 - t * 0.4})`
            );
            shellGradient.addColorStop(
              1,
              `rgba(21,128,61,${0.8 - t * 0.5})`
            );
          }

          // Shell body (rounded rect)
          const padding = 3;
          const w = GRID_SIZE - padding * 2;
          const h = GRID_SIZE - padding * 2;
          const rx = x + padding;
          const ry = y + padding;
          const r = 6;

          ctx.fillStyle = shellGradient;
          ctx.beginPath();
          roundedRect(ctx, rx, ry, w, h, r);
          ctx.fill();

          // Shell outline
          ctx.strokeStyle = isHead
            ? "rgba(250, 204, 21, 0.9)"
            : "rgba(15, 118, 110, 0.8)";
          ctx.lineWidth = isHead ? 2 : 1;
          ctx.stroke();

          // Shell pattern lines
          ctx.save();
          ctx.clip();
          ctx.strokeStyle = "rgba(15, 118, 110, 0.7)";
          ctx.lineWidth = 1;
          ctx.beginPath();
          ctx.moveTo(rx + w / 2, ry + 2);
          ctx.lineTo(rx + w / 2, ry + h - 2);
          ctx.moveTo(rx + 2, ry + h / 2);
          ctx.lineTo(rx + w - 2, ry + h / 2);
          ctx.stroke();
          ctx.restore();

          if (isHead) {
            // Turtle head
            const headRadius = GRID_SIZE * 0.18;
            const headX = x + GRID_SIZE / 2;
            const headY = y - headRadius * 0.2; // slightly above shell

            ctx.fillStyle = "#22c55e";
            ctx.beginPath();
            ctx.arc(headX, headY, headRadius, 0, Math.PI * 2);
            ctx.fill();

            // Eyes
            const eyeOffset = headRadius * 0.45;
            const eyeY = headY - headRadius * 0.2;
            ctx.fillStyle = "#020617";
            ctx.beginPath();
            ctx.arc(headX - eyeOffset, eyeY, headRadius * 0.22, 0, Math.PI * 2);
            ctx.arc(headX + eyeOffset, eyeY, headRadius * 0.22, 0, Math.PI * 2);
            ctx.fill();
          }
        });

        if (isGameOver) {
          drawGameOverOverlay();
        }
      }

      function roundedRect(ctx, x, y, width, height, radius) {
        ctx.moveTo(x + radius, y);
        ctx.lineTo(x + width - radius, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
        ctx.lineTo(x + width, y + height - radius);
        ctx.quadraticCurveTo(
          x + width,
          y + height,
          x + width - radius,
          y + height
        );
        ctx.lineTo(x + radius, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
        ctx.lineTo(x, y + radius);
        ctx.quadraticCurveTo(x, y, x + radius, y);
      }

      function drawGameOverOverlay() {
        ctx.save();
        ctx.fillStyle = "rgba(0, 0, 0, 0.65)";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        ctx.textAlign = "center";
        ctx.textBaseline = "middle";

        ctx.font = "bold 32px Orbitron, system-ui";
        ctx.fillStyle = "#ff3366";
        ctx.shadowColor = "rgba(255, 51, 102, 0.8)";
        ctx.shadowBlur = 18;
        ctx.fillText("TURTLE DEREZZED", canvas.width / 2, canvas.height / 2 - 16);

        ctx.font = "12px Orbitron, system-ui";
        ctx.fillStyle = "#e5f4ff";
        ctx.shadowBlur = 0;
        ctx.fillText(
          "Press SPACE or click START to reboot the shell",
          canvas.width / 2,
          canvas.height / 2 + 16
        );
        ctx.restore();
      }

      function setDirection(x, y) {
        // Prevent 180-degree reversal
        if (snake.length > 1 && x === -direction.x && y === -direction.y) {
          return;
        }
        nextDirection = { x, y };
      }

      function handleKey(e) {
        const key = e.key;
        if (key === "ArrowUp" || key === "w" || key === "W") {
          setDirection(0, -1);
        } else if (key === "ArrowDown" || key === "s" || key === "S") {
          setDirection(0, 1);
        } else if (key === "ArrowLeft" || key === "a" || key === "A") {
          setDirection(-1, 0);
        } else if (key === "ArrowRight" || key === "d" || key === "D") {
          setDirection(1, 0);
        } else if (key === " " || key === "Spacebar") {
          if (!intervalId) {
            resetGame();
          }
        }
      }

      // Event listeners
      window.addEventListener("keydown", handleKey);
      startBtn.addEventListener("click", () => {
        if (!intervalId) {
          resetGame();
        }
      });

      // Initial static render
      draw();
    })();
  </script>
</body>
</html>
